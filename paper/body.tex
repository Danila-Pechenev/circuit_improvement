\maketitle

\begin{abstract}
Finding exact circuit size 
is a~notorious optimization
problem in practice. Whereas modern computers 
and algorithmic techniques allow to~find a~circuit 
of~size seven in~blink of an~eye, it~may take more 
than a~week to~search for a~circuit of~size thirteen.
One of the reasons of~this behavior is~that the search 
space is~enormous: the number of~circuits of size~$s$ 
is~$s^{\Theta(s)}$, the number of~Boolean functions on~$n$ variables is~$2^{2^n}$.

In~this paper, we~explore the following natural
heuristic idea for decreasing the size of
a~given circuit: go through all its subcircuits
of moderate size and check whether 
any of them can be improved by reducing to~SAT. 
This may be viewed
as a~local search approach: we search for a~smaller
circuit in a~ball around a~given circuit.
We~report the results of experiments with various symmetric functions. 
\end{abstract}

%\tableofcontents
%\clearpage
%\listoftodos



\section{Boolean Circuits}
A~Boolean \emph{straight line program} 
of size~$r$ for input variables $(x_1, \dotsc, x_n)$ 
is a~sequence of~$r$~instructions where each 
instruction $g \gets h \circ k$ 
applies a~binary Boolean operation~$\circ$ to 
two operands $h,k$ each of which is either an~input bit 
or the result of a~previous instruction. 
If $m$~instructions are designated as outputs,
the straight line program computes a~function 
$\{0,1\}^n \to \{0,1\}^m$ in a~natural way. 
We denote the set of all such functions by $B_{n,m}$ and we let $B_n=B_{n,1}$.
For 
a~Boolean function $f \colon \{0,1\}^n \to \{0,1\}^m$,
by $\size(f)$ we denote the minimum size of 
a~straight line program
computing~$f$. A~Boolean \emph{circuit} 
shows a~flow graph of a~program.

Figure~\ref{figure:sum23} gives an~example for
the 
$\SUM_n \colon \{0,1\}^n \to \{0,1\}^l$ function 
that computes the binary representation of~the sum of~$n$~bits:
\[\SUM_n(x_1, \dotsc, x_n)=(w_0, w_1, \dotsc, w_{l-1})\colon \sum_{i=1}^{n}x_i=\sum_{i=0}^{l-1}2^iw_i \text{, \, where } l=\lceil \log_2(n+1)\rceil \, .\]
This function transforms $n$~bits 
of weight~0 into $l$~bits 
of~weights $(0,1,\dotsc,l-1)$.
%
\begin{figure}[t]
\begin{minipage}{.28\textwidth}
\begin{minted}{python}
def sum2(x1, x2):
    w0 = x1 ^ x2
    w1 = x1 * x2
    return w0, w1
\end{minted}
\end{minipage}
\begin{minipage}{.18\textwidth}
\begin{tikzpicture}[label distance=-.9mm,scale=.9]
\foreach \n/\x/\y in {1/0/1, 2/1/1}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate, label=left:$w_1$] (g1) at (0,0) {$\land$};
\node[gate, label=right:$w_0$] (g2) at (1,0) {$\oplus$};
\foreach \f/\t in {x1/g1, x1/g2, x2/g1, x2/g2}
  \draw[->] (\f) -- (\t);
\end{tikzpicture}
\end{minipage}
\begin{minipage}{.33\textwidth}
\begin{minted}{python}
def sum3(x1, x2, x3):
    a = x1 ^ x2
    b = x2 ^ x3
    c = a | b
    w0 = a ^ x3
    w1 = c ^ w0
    return w0, w1
\end{minted}
\end{minipage}
\begin{minipage}{.18\textwidth}
~
\begin{tikzpicture}[label distance=-.9mm,scale=.9]
\foreach \n/\x/\y in {1/0/3, 2/1/3, 3/2/3}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate,label=left:$a$] (g1) at (0.5,2) {$\oplus$};
\node[gate,label=left:$b$] (g2) at (1.5,2) {$\oplus$};
\node[gate,label=left:$c$] (g3) at (0.5,1) {$\lor$};
\node[gate, label=right:$w_0$] (g4) at (1.5,1) {$\oplus$};
\node[gate, label=right:$w_1$] (g5) at (0.5,0) {$\oplus$};
\foreach \f/\t in {x1/g1, x2/g1, x2/g2, x3/g2, g1/g3, g2/g3, g1/g4, g3/g5, g4/g5}
  \draw[->] (\f) -- (\t);
\path (x3) edge[bend left,->] (g4);
\end{tikzpicture}
\end{minipage}
\caption{Optimal size straight line programs and circuits for $\SUM_2$ and $\SUM_3$. These two circuits are known as~\emph{half adder} and \emph{full adder}.}
\label{figure:sum23}
\end{figure}
%
The straight line
programs are given 
in~\texttt{Python} programming language.
This makes particularly easy to~verify their correctness.
For example, the program for $\SUM_3$ can be verified
with just three lines of code:
\begin{minted}{python}
from itertools import product


for x1, x2, x3 in product(range(2), repeat=3):
    w0, w1 = sum3(x1, x2, x3)    
    assert x1 + x2 + x3 == w0 + 2 * w1
\end{minted}

Determining $\size(f)$ requires
proving lower bounds:
to~show that $\size(f)> \alpha$,
one needs to~prove that \emph{every} circuit
of~size at~most~$\alpha$ does not compute~$f$.
Known lower bounds are far from being satisfactory:
the strongest known lower bound for a~function family
in~NP is~$(3+1/86)n-o(n)$~\cite{DBLP:conf/focs/FindGHK16}.
Here, by a~\emph{function family} we mean an~infinite sequence of~functions $\{f_n\}_{n=1}^{\infty}$ where $f_n \in B_n$. 

Even proving lower bounds for specific functions (rather than function families) is~difficult. Brute force approaches become impractical quickly: $|B_n|=2^{2^n}$, hence already for $n=6$, one cannot just enumerate all 
functions from~$B_n$; also, the number of~circuits 
of~size~$s$ is $s^{\Theta(s)}$, hence checking all circuits of size~$s$ takes reasonable time for small values of~$s$ only.
Knuth~\cite{Knuth:2008:ACP:1377542} found the exact circuit size of all functions from~$B_4$ and~$B_5$.

Finding the exact value of $\size(f)$ for $f \in B_6$
is~already a~difficult computational task for modern
computers and techniques. One approach 
is~to~translate a~statement ``there exists a~circuit 
of~size~$s$ computing~$f$'' to a~Boolean formula and 
to~pass~it to~a~SAT-solver. Then, if the formula 
is~satisfiable, one decodes a~circuit from its satisfying 
assignment; otherwise, one gets a~(computer generated) proof of a~lower bound $\size(f) > s$. This circuit synthesis approach was proposed 
by~Kojevnikov et al.~\cite{DBLP:conf/sat/KojevnikovKY09}
and, since then, has been used in various circuit synthesis programs (\texttt{abc}~\cite{abc}, \texttt{mockturtle}~\cite{EPFLLibraries}, \texttt{sat-chains}~\cite{knuthreduction}).

The state-of-the-art SAT-solvers are surprisingly efficient and allow to~handle
various practically important problems (with millions
of~variables) and even help to~resolve open
problems~\cite{DBLP:conf/cade/BrakensiekHMN20}.
Still, already for small values of $n$~and~$s$ the problem
of~finding a~circuit of~size~$s$ for a~function from~$B_n$
is~difficult for SAT-solvers.
We demonstrate the limits
of~this approach on~\emph{counting} functions:
\[\MOD_n^{m,r}=[x_1+\dotsb+x_n \equiv r \bmod m]\]
(here, $[\cdot]$ is the Iverson bracket: $[S]$~is equal to~$1$ if $S$~is true and is equal to~$0$ otherwise).
Using SAT-solvers, Knuth~\cite[solution to exercise~$480$]{Knuth:2015:ACP:2898950}
found $\size(\MOD_n^{3,r})$ for all $3 \le n \le 5$ and all $0 \le r \le 2$. Based on the found numbers, he made the following conjecture:
\begin{equation}\label{conjecture}
\size(\MOD_n^{3,r})=3n-5-[(n+r) \equiv r\bmod 3] \text{ for all $n \ge 3$ and $r$.}
\end{equation}
He was also able to find the circuit size 
for the $n=6,r=0$ case and wrote: ``The case $n=6$ and $r \neq 0$, which lies tantalizingly close to the limits of 
today's solvers, is still unknown.'' 

To~summarize, our current abilities for checking whether there exists a~Boolean circuit of~size~$s$ are roughly the following: 
\begin{itemize}
\item for $s \le 6$, this can be~done in a~few seconds;
\item for $7 \le s \le 12$, this can (sometimes) 
be~done in a~few days;
\item for $s \ge 13$, this is~out of~reach.
\end{itemize}

In~this paper, we explore the limits of the following natural idea: given a~circuit, try to~improve its size by~improving (using SAT-solvers, for example) the size 
of~its subcircuit of~size seven. This is a~kind of a~local search approach: we~have no~possibility to~go through the whole space of all circuits, but we can at~least
search in a~neighborhood of a~given circuit. 
This allows~us to~work with circuits consisting
of many gates. 

As the results of experiments, we show several circuits
for which the approach described above leads to improved upper bounds. In particular, we support Knuth's conjecture~\eqref{conjecture} by~proving the matching upper bound. 
Also, we~present improvements for $\size(\SUM_n)$ for various small~$n$. 
Finally, we provide examples of~circuits that are
optimal locally, but not globally: our program is not able to find a~(known) smaller circuit since 
it~is 
``too different'' from the original circuit.

\section{Program Overview}
The program is~implemented in~\texttt{Python}.
We give a~high-level overview of~its main features below.
All the code shown below 
can be~found in~the 
file \texttt{tutorial.py} at~\cite{git-improvement}.
One may run~it after installing a~few \texttt{Python} modules. Alternatively, one may run the Jupyter notebook
\texttt{tutorial.ipynb} in~the cloud without installing 
anything. To~do this, press the badge ``Colab'' 
at~\cite{git-improvement}.

\subsection{Manipulating Circuits}
This is done through the \mintinline{python}{Circuit}
class. One can load and save circuits as~well~as
print and draw them. A~nicely looking layout of
a~circuit is produced by the \texttt{pygraphviz} module \cite{pygraphviz}. The program also contains some built-in
circuits that can be used as~building blocks.
The following sample code constructs a~circuit
for $\SUM_5$ out of two full adders and 
one half adder. This construction is~shown 
in~Figure~\ref{figure:sumfive}(a). Then, 
the circuit is verified via the  
\mintinline{python}{check_sum_circuit} method. 
Finally, the circuit is drawn. As a~result, one gets
a~picture similar to~the one in~Figure~\ref{figure:sumfive}(b).

\inputminted[firstline=11,lastline=18]{python}{../tutorial.py}

\begin{figure}[t]
\begin{mypic}
\begin{scope}[scale=.9]
%\draw[help lines] (0,-5) grid (16,6);
\begin{scope}[yshift=-10mm]
\foreach \n in {1,...,5}
  \node[input] (\n) at (\n,6) {$x_{\n}$};
\draw (0.5, 5.5) rectangle (3.5, 4.5); \node at (2, 5) {$\SUM_3$};
\foreach \n in {1, 2, 3}
  \draw[->] (\n) -- (\n, 5.5);
\draw (2.5, 3.5) rectangle (5.5, 2.5); \node at (4, 3) {$\SUM_3$};
\path (3, 4.5) edge[->] node[l] {0} (3, 3.5);
\foreach \n in {4, 5}
  \draw[->] (\n) -- (\n, 3.5);
\draw (1.5, 1.5) rectangle (3.5, 0.5); \node at (2.5, 1) {$\SUM_2$};
\path (2, 4.5) edge[->] node[l] {1} (2, 1.5);
\path (3, 2.5) edge[->] node[l] {1} (3, 1.5);
\node[input] (w2) at (2,-1) {$w_2$};
\node[input] (w1) at (3,-1) {$w_1$};
\node[input] (w0) at (4.5,-1) {$w_0$};
\path (2, 0.5) edge[->] node[l] {1} (w2);
\path (3, 0.5) edge[->] node[l] {0} (w1);
\path (4.5, 2.5) edge[->] node[l] {0} (w0);
\end{scope}

\begin{scope}[label distance=-1mm, xshift=70mm, yshift=20mm]
\foreach \n/\x/\y in {1/0/3, 2/1/3, 3/2/3, 4/2.5/1, 5/3.5/1}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate,label=left:$g_1$] (g1) at (0.5,2) {$\oplus$};
\node[gate,label=left:$g_2$] (g2) at (1.5,2) {$\oplus$};
\node[gate,label=left:$g_3$] (g3) at (0.5,1) {$\lor$};
\node[gate,label=left:$g_4$] (g4) at (1.5,1) {$\oplus$};
\node[gate,label=left:$g_5$] (g5) at (0.5,0) {$\oplus$};
\node[gate,label=left:$g_6$] (g6) at (2,-1) {$\oplus$};
\node[gate,label=right:$g_7$] (g7) at (3,-1) {$\oplus$};
\node[gate,label=right:$g_8$] (g8) at (2,-2) {$\lor$};
\node[gate, label=right:$w_0$] (g9) at (3,-2) {$\oplus$};
\node[gate, label=right:$g_9$] (g10) at (2,-3) {$\oplus$};
\node[gate, label=right:$w_1$] (g11) at (2,-4) {$\oplus$};
\node[gate, label=left:$w_2$] (g12) at (1,-4) {$\land$};

\foreach \f/\t in {x1/g1, x2/g1, x2/g2, x3/g2, g1/g3, g2/g3, g1/g4, g3/g5, g4/g5, g4/g6, x4/g6, x4/g7, x5/g7, g6/g8, g7/g8, g8/g10, g6/g9, g9/g10, g10/g11, g10/g12}
  \draw[->] (\f) -- (\t);

\path (x3) edge[->,bend left] (g4);
\path (x5) edge[->,bend left=35] (g9);
\path (g5) edge[->,bend right=25] (g11);
\path (g5) edge[->,bend right=15] (g12);

\draw[dashed] (-0.5,-0.25) rectangle (2,2.5);
\draw[dashed] (1.25,-3.25) rectangle (4,-0.5);
\draw[dashed] (0,-3.5) rectangle (3,-4.5);
\end{scope}

\begin{scope}[label distance=-1mm, xshift=120mm, yshift=20mm]
\foreach \n/\x/\y in {1/0/3, 2/1/3, 3/2/3, 4/2.5/1, 5/3.5/1}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate,label=left:$g_1$] (g1) at (0.5,2) {$\oplus$};
\node[gate,label=left:$g_2$] (g2) at (1.5,2) {$\oplus$};
\node[gate,label=left:$g_3$] (g3) at (0.5,1) {$\lor$};
\node[gate,label=left:$g_4$] (g4) at (1.5,1) {$\oplus$};
\node[gate,label=left:$g_5$] (g5) at (0.5,0) {$\oplus$};
\node[gate,label=left:$g_6$] (g6) at (2,0) {$\oplus$};
\node[gate,label=right:$g_7$] (g7) at (3,0) {$\oplus$};
\node[gate,label=right:$g_8$] (g8) at (2,-1) {$>$};
\node[gate, label=right:$w_0$] (g9) at (3,-1) {$\oplus$};
\node[gate, label=right:$w_1$] (g10) at (2,-2) {$\oplus$};
\node[gate, label=right:$w_2$] (g11) at (1.5,-3) {$>$};

\foreach \f/\t in {x1/g1, x2/g1, x2/g2, x3/g2, g1/g3, g2/g3, g1/g4, g3/g5, g4/g5, x4/g6, g4/g6, x4/g7, x5/g7, g6/g8, g7/g8, g7/g9, g3/g10, g8/g10, g10/g11, g5/g11}
  \draw[->] (\f) -- (\t);

\path (x3) edge[->,bend left] (g4);
\path (g4) edge[->,bend left=20] (g9);
\end{scope}

\foreach \x/\n in {3/a, 9/b, 14/c}
  \node at (\x,-3) {(\n)};
\end{scope}
\end{mypic}
\caption{(a)~A~schematic circuit for $\SUM_5$ composed out of two full adders and one half adder. (b)~The corresponding circuit of size~$12$. (c)~An~improved circuit of size~$11$.}
\label{figure:sumfive}
\end{figure}

\subsection{Finding Efficient Circuits}
The method \mintinline{python}{find_circuit}
checks whether there exists a~circuit of the required
size for a~given Boolean function. For example, 
one may discover the full adder as follows. (The function
\mintinline{python}{sum_n} returns the list of $\lceil \log_2(n+1) \rceil$ bits of~the binary representation of~the sum of~$n$~bits.)

\inputminted[firstline=22,lastline=27]{python}{../tutorial.py}

This is~done by~encoding the task as~a~CNF formula
and invoking the PicoSAT solver~\cite{DBLP:journals/jsat/Biere08} (via the \texttt{pycosat} module~\cite{pycosat}). The reduction to~SAT is~described 
in~\cite{DBLP:conf/sat/KojevnikovKY09}. 

As~mentioned in~the introduction, the limits 
of~applicability of~this approach (for finding a~circuit 
of~size~$s$) are roughly the following:
for $s \le 6$, it~usually works in~less than a~minute;
for $7 \le s \le 12$, it~may already take up~to 
several hours or days; for $s \ge 13$, it~becomes almost impractical. The running time may vary a~lot
for inputs of the same length. In~particular,
it usually takes much longer to~prove that 
the required circuit does not exist (by~proving that the corresponding formula is~unsatisfiable).

\todo[inline]{various bases}

The program allows to~predefine some of the gates and 
wires of a~circuit. We demonstrate this functionality
later in~the text.

\subsection{Improving Circuits}
The method \mintinline{python}{improve_circuit}
goes through all subcircuits of a~given size
of a~given circuit and checks whether any 
of~them can be~replaced by a~smaller subcircuit 
(computing the same function) via \mintinline{python}{find_circuit}. For example, applying this method 
to~the circuit from Figure~\ref{figure:sumfive}(b)
gives the circuit from Figure~\ref{figure:sumfive}(c)
in~nine~seconds. 

\todo[inline]{Nikita, please remove run\_improve\_circuit method!! Instead, use improve\_circuit method. (For the user, it is not at all clear why we have two such methods.)}

\begin{minted}{python}
improved_circuit = run_improve_circuit(add_sum5_suboptimal, 5,
                            subcircuit_size=5, connected=True)
print(improved_circuit)
improved_circuit.draw('sum5')
\end{minted}
%
This circuit can~be also found via \mintinline{python}{find_circuit} directly, but it takes about seven hours.



\section{Evaluation}
In~this section, we~report the results of~experiments
with various symmetric functions. A~function $f(x_1,\dotsc,x_n)$ is called \emph{symmetric} if~its value depends on~$\sum_{i=1}^nx_i$ only. They are among the most basic Boolean functions:
\begin{itemize}
\item to~specify an~arbitrary Boolean function
from~$B_n$, one needs
to~write down its truth table of length~$2^n$; symmetric functions allow for more compact representation: it is enough to specify $n+1$ bits (for each of $n+1$ values
of~$\sum_{i=1}^nx_i$);
\item circuit complexity of almost all functions
of~$n$ variables is exponential ($\Theta(2^n/n)$), whereas any symmetric function can~be computed by a~linear size circuit ($O(n)$).
\end{itemize}
Despite simplicity of~symmetric functions, we still do~not
know how optimal circuits look like for most of~them. Below, we~present new circuits for some of these functions.

\subsection{Sum Function}
The $\SUM$ function is a~fundamental symmetric function: for any symmetric $f \in B_n$, $\size(f)\le \size(\SUM_n)+o(n)$. The reason for this is that any function from~$B_n$ can be~computed by a~circuit of size $O(2^n/n)$ by the results of Muller~\cite{M56} and Lupanov~\cite{Lup59}. This allows to compute any symmetric $f(x_1, \dotsc, x_n) \in B_n$ as follows: first, compute $\SUM_n(x_1, \dotsc, x_n)$ using $\size(\SUM_n)$ gates; then, compute the resulting bit using at most $O(2^{\log n}/\log n)=o(n)$ gates. For the same reason, any lower bound $\size(f) \le \alpha$ for
a~symmetric function~$f \in B_n$ implies a~lower bound $\size(\SUM_n) \le \alpha-o(n)$. Currently, we know the following bounds for $\SUM_n$:
\[2.5n-O(1) \le \size(\SUM_n) \le 4.5n+o(n) \, .\]
The lower bound is~due to~Stockmeyer~\cite{DBLP:journals/mst/Stockmeyer77}, the upper bound is~due to~Demenkov et al.~\cite{DBLP:journals/ipl/DemenkovKKY10}.

A~circuit for $\SUM_n$ can~be constructed from circuits for $\SUM_k$ for some small~$k$. For example,
using full and half adders as~building blocks, one can compute $\SUM_n$ (for any~$n$) by a~circuit of size $5n$ as~follows. Start from $n$~bits $(x_1, \dotsc, x_n)$ of~weight~$0$. While there are three bits of the same weight~$k$, replace them by~two bits of weights~$k$ and~$k+1$ using a~full adder. This way, one gets at~most two bits of~each weight $0,1,\dotsc,l-1$ ($l=\lceil \log_2(n+1)\rceil$) in at most $5(n-l)$ gates (as each full adder reduces the number of~bits). To~leave exactly one bit
of~each weight, it suffices to use at~most~$l$ half
or~full adders ($o(n)$ gates). Let~us denote the
size of the resulting circuit by~$s(n)$. The second row
of~Table~\ref{table:sum} shows the values of~$s(n)$ for
some $n \le 15$ (see~(28) in~\cite{Knuth:2008:ACP:1377542}).

\begin{table}
\begin{center}
\begin{tabular}{lrrrrrrrrrrrrrrrrrrrrrr}
\toprule
$n$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $10$ & $15$
\\
\midrule
$s(n)$ &$2$ & $5$ & $9$ & $12$ & $17$ & $20$ & $26$ & $29$& $34$&
%$37$ & $44$ & $47$ & $52$ &
$55$
\\
$\size(\SUM_n)$ & $2$ & $5$ & $9$ & $11$
& $\le 16$ & $\le 19$ & $\le 25$ & $\le 27$
& $\le 32$ & $\le 53$
\\
\bottomrule
\end{tabular}
\end{center}
\caption{The first line shows the value of~$n$. The second line gives the size $s(n)$ of~a~circuit for $\SUM_n$
composed out~of half and full adders. The third row shows known bounds for $\size(\SUM_n)$.}
\label{table:sum}
\end{table}

In a~similar fashion, one can get an~upper bound (see Theorem~1 in~\cite{DBLP:conf/date/Kulikov18})
\begin{equation}\label{eq:sumupper}
\size(\SUM_n) \le \frac{\size(\SUM_k)}{k-\lceil \log_2(k+1) \rceil} \cdot n + o(n) \, .
\end{equation}
This motivates the search for efficient circuits
for $\SUM_k$ for small values of~$k$. The bottom row
of~Table~\ref{table:sum} gives upper bounds that
we~were able to~find using the program
(the upper bounds for $n \le 7$ were found
by~Knuth~\cite{Knuth:2008:ACP:1377542}).
The table shows that the first value where $s(n)$ is not
optimal is $n=5$. The best upper bound for $\SUM_n$ given
by~\eqref{eq:sumupper} is $4.75n+o(n)$ for $n=7$. The upper
bound for $n=15$ is $53n/11+o(n)$ which is worse than the
previous upper bound. But if it~turned out that
$\size(\SUM_{15}) \le 52$,
it~would give a~better upper bound.

The found circuits for $\SUM_n$ for $n \le 15$
does not allow to~improve the strongest known upper bound
$\size(\SUM_n) \le 4.5n+o(n)$ due to~Demenkov et al.~\cite{DBLP:journals/ipl/DemenkovKKY10}. Below,
we~present several interesting observations on~the found circuits.

\subsubsection{Best Known Upper Bound for the SUM Function}
The optimal circuit of size~$11$ for $\SUM_5$ shown in~Figure~\ref{figure:sumfive}(c) can be~used to get an~upper bound $4.5n+o(n)$ for $\size(\SUM_n)$
(though not through~\eqref{eq:sumupper} directly).
To~do this,
consider two consecutive $\SUM_3$ circuits shown in~Figure~\ref{figure:mdfa}(a).
%
\begin{figure}
\begin{center}
\begin{tikzpicture}
\begin{scope}[scale=.7]
%\draw[help lines] (0,0) grid (10,6);
\draw (1,0) rectangle (3,2); \node at (2,1) {$\SUM_3$};
\draw (5,0) rectangle (7,2); \node at (6,1) {$\SUM_3$};
\foreach \n/\x/\y in {3/0/1, 2/1.5/3, 1/2.5/3, 4/5.5/3, 5/6.5/3}
  \node[input] (\n) at (\x,\y) {$x_{\n}$};
\foreach \n/\t/\x/\y in {a1/a_1/2/-1, b1/b_1/6/-1, b0/b_0/8/1}
  \node[input] (\n) at (\x,\y) {$\t$};
\draw[->] (3)--(1,1);
\draw[->] (2)--(1.5,2);
\draw[->] (1)--(2.5,2);
\draw[->] (4)--(5.5,2);
\draw[->] (5)--(6.5,2);
\draw[->] (3,1)--(5,1);
\draw[->] (7,1)--(b0);
\draw[->] (2,0)--(a1);
\draw[->] (6,0)--(b1);

\node at (-1,1) {(a)};
\end{scope}

\begin{scope}[scale=.7,yshift=-60mm]
%\draw[help lines] (0,0) grid (10,6);
\draw (1,0) rectangle (7,2); \node at (4,1) {MDFA};
\foreach \n/\x/\y in {3/0/1, 2/1.5/4, 1/2.5/4, 4/5.5/4, 5/6.5/4}
  \node[input] (\n) at (\x,\y) {$x_{\n}$};
\node[gate] (xor1) at (2.5,3) {$\oplus$};
\node[gate] (xor2) at (6.5,3) {$\oplus$};
\foreach \n/\t/\x/\y in {a1/a_1/2/-1, b1/{a_1 \oplus b_1}/6/-1, b0/b_0/8/1}
  \node[input] (\n) at (\x,\y) {$\t$};
\draw[->] (3)--(1,1);
\draw[->] (2)--(1.5,2);
\draw[->] (1) -- (xor1); \draw[->] (2) -- (xor1);
\draw[->] (xor1) -- (2.5,2);
\draw[->] (4)--(5.5,2);
\draw[->] (5)-- (xor2); \draw[->] (xor2) -- (6.5,2); \draw[->] (4) -- (xor2);
%\draw[->] (3,1)--(5,1);
\draw[->] (7,1)--(b0);
\draw[->] (2,0)--(a1);
\draw[->] (6,0)--(b1);

\node at (-1,1) {(b)};
\end{scope}

\begin{scope}[yscale=.8, xshift=80mm, yshift=-20mm]
%\draw[help lines] (0,-3) grid (4,4);
\draw[draw=none, rounded corners=0,fill=gray!20] (0,1.5)--(1,1.5)--(1,2.5)--(2,2.5)--(2,0.5)--(2.5,0.5)--(2.5,-0.5)--(3.5,-0.5)--
(3.5,-2.5)--(0,-2.5)--(0,1.5);


\foreach \n/\x/\y in {1/0/3, 2/1/3, 3/2/3, 4/2.5/1, 5/3.5/1}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate] (g1) at (0.5,2) {$\oplus$};
\node[gate] (g2) at (1.5,2) {$\oplus$};
\node[gate] (g3) at (0.5,1) {$\lor$};
\node[gate] (g4) at (1.5,1) {$\oplus$};
\node[gate, label=left:$a_1$] (g5) at (0.5,0) {$\oplus$};
\node[gate] (g6) at (2,0) {$\oplus$};
\node[gate] (g7) at (3,0) {$\oplus$};
\node[gate] (g8) at (2,-1) {$>$};
\node[gate, label=right:$b_0$] (g9) at (3,-1) {$\oplus$};
\node[gate, label=right:$a_1 \oplus b_1$] (g10) at (2,-2) {$\oplus$};
\node[gate] (g11) at (1.5,-3) {$>$};

\foreach \f/\t in {x1/g1, x2/g1, x2/g2, x3/g2, g1/g3, g2/g3, g1/g4, g3/g5, g4/g5, x4/g6, g4/g6, x4/g7, x5/g7, g6/g8, g7/g8, g7/g9, g3/g10, g8/g10, g10/g11, g5/g11}
  \draw[->] (\f) -- (\t);

\path (x3) edge[->,bend left] (g4);
\path (g4) edge[->,bend left=20] (g9);

\node at (1.5,-4) {(c)};
\end{scope}
\end{tikzpicture}
\end{center}
\caption{(a)~Two consecutive $\SUM_3$ blocks. (b)~The $\MDFA$ block. (c)~The highlighted part of the optimal circuit
for $\SUM_5$ computes $\MDFA$.}
\label{figure:mdfa}
\end{figure}
%
Its specification~is: $x_1+\dotsb+x_5=b_0+2(a_1+b_1)$, its size is~equal to~10. One can construct a~similar block, called MDFA (for modified double full adder), of size~8, whose specification is
\[\MDFA(x_1 \oplus x_2, x_2, x_3, x_4, x_4 \oplus x_5)=(b_0, a_1, a_1 \oplus b_1) \, ,\]
see Figure~\ref{figure:mdfa}(b).
The fact that $\MDFA$ uses the encoding $(p, p \oplus q)$ for pairs of bits $(p,q)$, allows to use~it recursively
to~compute $\SUM_n$: first, compute $x_1 \oplus x_2, x_3 \oplus x_4, \dotsc, x_{n-1} \oplus x_n$ ($n/2$ gates); then,
apply~$n/2$ $\MDFA$ blocks ($4n$ gates).
The $\MDFA$ block was constructed by~Demenkov et al.~\cite{DBLP:journals/ipl/DemenkovKKY10} in~a~semiautomatic
manner. And it turns out that $\MDFA$ is just a~subcircuit of the optimal circuit for $\SUM_5$! See Figure~\ref{figure:mdfa}(c).


\subsubsection{Best Known Circuits for SUM with New Structure}

For many upper bounds from the bottom row of~Table~\ref{table:sum}, we found circuits with the following interesting structure: the first thing the circuit computes is $x_1 \oplus x_2 \oplus \dotsb \oplus x_n$; moreover the variables $x_2, \dotsc, x_n$ are used for this only. This is best illustrated by an~example~--- see Figure~\ref{figure:xorsum}.

\begin{figure}[t]
\begin{mypic}
\begin{scope}[scale=.9]
%\draw[help lines] (0,-5) grid (16,6);
\begin{scope}[xshift=20mm, yshift=30mm]
%\draw[help lines] (0,-3) grid (4,4);
\draw[draw=none, rounded corners=0,fill=gray!20] (0.6,2.5)--(0.6,3.5)--(2.4,3.5)--(2.4,2.5);

\foreach \n/\x/\y in {1/0/4, 2/1/4, 3/2/4}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate] (g1) at (1,3) {$\oplus$};
\node[gate,label=right:$w_0$] (g2) at (2,3) {$\oplus$};
\node[gate] (g3) at (0,2) {$\oplus$};
\node[gate] (g4) at (1,1.5) {$\lor$};
\node[gate, label=right:$w_1$] (g5) at (2,1) {$\oplus$};
\foreach \f/\t in {x1/g1, x2/g1, g1/g2, x3/g2, x1/g3, g2/g3, g1/g4, g3/g4, g2/g5, g4/g5}
  \draw[->] (\f) -- (\t);
\end{scope}

\begin{scope}[label distance=-1mm, xshift=70mm, yshift=20mm]
%\draw[help lines] (0,-3) grid (4,4);
\draw[draw=none, rounded corners=0,fill=gray!20] (0.6,3.5)--(0.6,4.5)--(3.4,4.5)--(3.4,3.5);
\foreach \n/\x/\y in {1/0/5, 2/1/5, 3/2/5, 4/3/5}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate] (g1) at (1,4) {$\oplus$};
\node[gate] (g2) at (2,4) {$\oplus$};
\node[gate,label=right:$w_0$] (g3) at (3,4) {$\oplus$};

\node[gate] (g4) at (0.5,3) {$\oplus$};
\node[gate] (g5) at (3,3) {$>$};

\node[gate] (g6) at (1,2) {$\lor$};
\node[gate] (g7) at (2,1.5) {$\oplus$};
\node[gate,label=right:$w_1$] (g8) at (3,1) {$\oplus$};

\node[gate,label=left:$w_2$] (g9) at (2,0.5) {$>$};
\foreach \f/\t in {x1/g1, x2/g1, g1/g2, x3/g2, g2/g3, x4/g3, x1/g4, g2/g4, g2/g5, g3/g5, g4/g6, g1/g6, g6/g7, g2/g7, g7/g8, g5/g8, g8/g9, g7/g9}
  \draw[->] (\f) -- (\t);
\end{scope}

\begin{scope}[label distance=-1mm, xshift=120mm, yshift=20mm]
%\draw[help lines] (0,-3) grid (4,4);
\draw[draw=none, rounded corners=0,fill=gray!20] (0.6,3.5)--(0.6,4.5)--(4.4,4.5)--(4.4,3.5);
\foreach \n/\x/\y in {1/0/5, 2/1/5, 3/2/5, 4/3/5, 5/4/5}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate] (g1) at (1,4) {$\oplus$};
\node[gate] (g2) at (2,4) {$\oplus$};
\node[gate] (g3) at (3,4) {$\oplus$};
\node[gate,label=right:$w_0$] (g4) at (4,4) {$\oplus$};

\node[gate] (g5) at (0.5,3) {$\oplus$};
\node[gate] (g6) at (4,3) {$\oplus$};

\node[gate] (g7) at (1,2) {$\lor$};
\node[gate] (g8) at (3.5,2) {$>$};

\node[gate] (g9) at (2,1) {$\oplus$};
\node[gate,label=right:$w_1$] (g10) at (3,1) {$\oplus$};

\node[gate,label=right:$w_2$] (g11) at (2.5,0) {$>$};

\foreach \f/\t in {x1/g1, x2/g1, g1/g2, x3/g2, g2/g3, x4/g3, g3/g4, x5/g4, x1/g5, g2/g5, g2/g6, g4/g6, g1/g7, g5/g7, g3/g8, g6/g8, g2/g9, g7/g9, g8/g10, g7/g10, g9/g11, g10/g11}
  \draw[->] (\f) -- (\t);
\end{scope}

%\foreach \x/\n in {3/a, 9/b, 14/c}
%  \node at (\x,1) {(\n)};
\end{scope}
\end{mypic}
%\caption{(a)~$\SUM_3$. (b)~$\SUM_4$. (c)~$\SUM_5$.}
\caption{Optimal circuits computing $\SUM_n$
for $n=3,4,5$ with a~specific structure: every input,
except for~$x_1$, has out-degree~one.}
\label{figure:xorsum}
\end{figure}

These circuits can be~found using the following code.
It~demonstrates two new useful features: fixing gates and forbidding wires between some pairs of~gates.

\begin{minted}{python}
def sum_n(x):
    return [(sum(x) >> i) & 1 for i in range(ceil(log2(len(x) + 1)))]


for n, size in ((3, 5), (4, 9), (5, 11)):
    circuit_finder = CircuitFinder(dimension=n, number_of_gates=size,
                                   function=sum_n)
    circuit_finder.fix_gate(n, 0, 1, '0110')
    for k in range(n - 2):
        circuit_finder.fix_gate(n + k + 1, k + 2, n + k, '0110')
    for i in range(1, n):
        for j in range(n, n + size):
            if i + n - 1 != j:
                circuit_finder.forbid_wire(i, j)
    circuit = circuit_finder.solve_cnf_formula(verbose=0)
    circuit.draw(f'sum{n}')
\end{minted}


\subsubsection{Optimal Circuits for Counting Modulo~4}
The optimal circuit for $\SUM_5$ can be used to construct
an~optimal circuit of~size $2.5n+O(1)$ for $\MOD_4^n$ due
to~Stockmeyer~\cite{DBLP:journals/mst/Stockmeyer77}.
To~do this, note that
there is a~subcircuit (of the circuit at~Figure~\ref{figure:sumfive}(c)) of size~9 that computes the two least significant bits ($w_0,w_1$) of $x_1+\dotsb+x_5$ (one removes the gates $g_5, w_2$). To~compute $x_1+\dotsb+x_n \bmod 4$, one first applies $\frac n4$ such blocks and then computes the parity of~the resulting bits of weight~1. The total size is~$9 \cdot \frac n4 + \frac n4=2.5n$. Thus,
the circuit that Stockmeyer constructed in~1977 by~hand,
nowadays can be~found automatically in~a~few seconds.


\subsection{Modulo-3 Function}
In~\cite{DBLP:conf/sat/KojevnikovKY09}, Kojevnikov et~al.
presented circuits of~size $3n+O(1)$ for $\MOD_n^{3,r}$ (for any~$r$). Later,
Knuth~\cite[solution to exercise~$480$]{Knuth:2015:ACP:2898950} analyzed their construction and proved an~upper
bound $3n-4$. Also, by~finding the exact values
for $\size(\MOD_n^{3,r})$ for all $3 \le n \le 5$ and all $0 \le r \le 2$, he~made the conjecture~\eqref{conjecture}.
Using our program, we~proved the conjectured upper bound for all~$n$.

\begin{theorem}\label{theorem:mod3upper}
For all $n \ge 3$ and all $r \in \{0,1,2\}$,
\[\size(\MOD_n^{3,r}) \le 3n-5-[(n+r) \equiv r\bmod 3] \,. \]
\end{theorem}

To~prove Knuth's conjecture, one also needs to~prove a~lower bound on $\size(\MOD_n^{3,r})$. The currently strongest known lower bound for $\size(\MOD_n^{3,r})$
is~$2.5n-O(1)$ due to~Stockmeyer~\cite{DBLP:journals/mst/Stockmeyer77}
(and no~stronger lower bound is known for any other symmetric function).

\begin{proof}
As~in~\cite{DBLP:conf/sat/KojevnikovKY09},
we~construct the required circuit out of~constant size blocks. Schematically, the circuit looks as~follows.

\begin{center}
\begin{tikzpicture}[scale=.8]
%\draw[help lines] (0,0) grid (16,6);

\foreach \x/\k in {0.5/1, 2.5/k, 4.5/{k+1}, 5.5/{k+2}, 6.5/{k+3}, 13.5/{n-l+1}, 15.5/n}
  \node[above] at (\x,2.5) {$x_{\k}$};

\foreach \x in {0, 4, 9, 13}
  \draw (\x,0) rectangle (\x+3,2);

\foreach \x in {0.5, 2.5, 4.5, 5.5, 6.5, 9.5, 10.5, 11.5, 13.5, 15.5}
  \draw[->] (\x,2.5) -- (\x,2);

\foreach \x/\y in {1.5/2.25, 14.5/2.25, 8/1}
  \node at (\x,\y) {$\dotsb$};

\foreach \a/\b in {3/4, 12/13, 7/7.5, 8.5/9} {
  \draw[->] (\a,1.5) -- (\b,1.5);
  \draw[->] (\a,0.5) -- (\b,0.5);
}

\draw[->] (16,1) -- (16.5,1);
\node at (1.5, 1) {$\IN_k$};
\node at (5.5, 1) {$\MID_3$};
\node at (10.5, 1) {$\MID_3$};
\node at (14.5, 1) {$\OUT_l^r$};
\end{tikzpicture}
\end{center}
%
Here, the $n$~input bits are passed from above.
What is passed from block to block (from left to~right)
is the pair of bits $(r_0, r_1)$ encoding the current remainder~$r$ modulo~$3$ as~follows: if $r=0$, then $(r_0,r_1)=(0,0)$; if $r=1$, then $(r_0,r_1)=(0,1)$; if $r=2$, then $r_0=1$. The first block $\IN_k$ takes the first $k$~input bits and computes the remainder of their sum modulo~$3$. It is followed by a~number of~$\MID_3$ blocks each of which takes the current remainder and three new input bits and computes the new remainder. Finally, the block~$\OUT_l^r$ takes the remainder and the last~$l$ input bits and outputs $\MOD_n^{3,r}$. The integers $k,l$ take values in~$\{2,3,4\}$ and $\{1,2,3\}$, respectively. Their exact values depend on~$r$ and $n \mod 3$ as~described below.

The theorem follows from the following upper bounds
on~the circuit size of the just introduced functions:
$\size(\IN_2) \le 2$,
$\size(\IN_3) \le 5$,
$\size(\IN_4) \le 7$,
$\size(\MID_3) \le 9$,
$\size(\OUT_2^0) \le 5$,
$\size(\OUT_1^1) \le 2$,
$\size(\OUT_3^2) \le 8$.
The corresponding circuits are presented in the Appendix
by a~straightforward \texttt{Python} code that verifies their correctness. (The presented code proves the mentioned upper bounds by~providing explicit circuits. We~have also verified that no~smaller circuits exist meaning that the
inequalities above are in fact equalities.)

Table~\ref{table:parameters} shows how to~combine
the blocks
to~get a~circuit computing~$\MOD_n^{3,r}$ of the required size. (Technically, it requires $n$~to~be at~least~$4$. For $n=3$, the corresponding circuits are easy to~construct.)

\begin{table}
\begin{center}
\begin{tabular}{cccc}
\toprule
& $n=3t$ & $n=3t+1$ & $n=3t+2$\\
\midrule
$r=0$
& $(4, t-2, 2)$, $(7, 5)$, $3n-6$
& $(2, t-1, 2)$, $(2, 5)$, $3n-5$
& $(3, t-1, 2)$, $(5, 5)$, $3n-5$
\\
$r=1$
& $(2, t-1, 1)$, $(2, 2)$, $3n-5$
& $(3, t-1, 1)$, $(5, 2)$, $3n-5$
& $(4, t-1, 1)$, $(7, 2)$, $3n-6$
\\
$r=2$
& $(3, t-2, 3)$, $(5, 8)$, $3n-5$
& $(4, t-2, 3)$, $(7, 8)$, $3n-6$
& $(2, t-1, 3)$, $(2, 8)$, $3n-5$
\\
\bottomrule
\end{tabular}
\end{center}
\caption{Choosing parameters $k, m, l$ depending on $n \mod 3$ and~$r$. The circuit is composed out of~blocks
as~follows: $\IN_k + m \times \MID_3 + \OUT_r^l$. For each
pair $(n \mod 3, r)$ we show three things: the triple
$(m, k, l)$; the sizes of~two blocks: $\size(\IN_k)$ and $\size(\OUT_r^l)$; the size of~the resulting circuit
computed as $s=\size(\IN_k)+9m+\size(\OUT_r^l)$. For example, the top left cell is read as follows: when $r=0$ and $n=3t$, we set $k=4,m=t-2,l=2$; the resulting circuit is then $\IN_4 + (t-2) \times \MID_3 + \OUT_0^2$; since $\size(\IN_4)=7$ and $\size(\OUT_0^2)=5$, the size of the circuit is $7+9(t-2)+5=9t-6=3n-6$.}
\label{table:parameters}
\end{table}
\end{proof}

\subsection{Threshold-2 Function}
Here, we present an~example of a~reasonably small circuit
that our program fails to~improve though a~better circuit
is~known. The reason is that these two circuits are quite
different. The function we are going to~consider is the threshold-2 function:
\[\THR_n^2(x_1, \dotsc, x_n)=[x_1+\dotsb+x_n \ge 2] \, .\]
It~is not difficult to~show that $\size(\THR_n^2) \le 3n-5$:
to~construct the corresponding circuit, perform one and
a~half iterations of~the bubble sort algorithm (where one sorts two bits $x,y$ as~follows: $\min\{x,y\}=x\lor y, \max\{x,y\} = x \land y$). Dunne~\cite{Dunne84} came~up with
a~circuit of size~$2n+o(n)$ based on~the following clever trick: organize the input bits into a~$\sqrt{n} \times \sqrt{n}$ matrix, compute the disjunction of all rows and columns, and proceed recursively. Sergeev~\cite{Sergeev2020} showed recently that the \emph{monotone} circuit size of $\THR_n^2$ is $2n+\Theta(\sqrt n)$.

For $n=12$, the bubble sort approach gives a~circuit of size $31$, whereas Dunne's circuit has size $29$. One can construct these two circuits as~follows.
\todo[inline]{Nikita, please add code here constructing and drawing both circuits}

\begin{minted}{python}
c = Circuit(input_labels=[f'x{i}' for i in range(1, 13)], gates={})
c.outputs = add_naive_thr2_circuit(c, c.input_labels)
c.draw('thr2naive')

c = Circuit(input_labels=[f'x{i}' for i in range(1, 13)], gates={})
c.outputs = add_efficient_thr2_circuit(c, c.input_labels, 3, 4)
c.draw('thr2efficient')
\end{minted}

\begin{figure}[t]
\begin{mypic}
\begin{scope}[scale=.9]
%\draw[help lines] (0,-5) grid (16,6);
\begin{scope}[xshift=20mm, yshift=30mm]
%\draw[help lines] (0,-3) grid (4,4);

\foreach \n/\x/\y in {1/0/12, 2/1/12, 3/2/12, 4/3/12, 5/4/12, 6/5/12, 7/6/12, 8/7/12, 9/8/12, 10/9/12, 11/10/12, 12/11/12}
  \node[input] (x\n) at (\x, \y) {$x_{\n}$};
\node[gate] (g1) at (0.3,11) {$\land$};
\node[gate] (g2) at (1,11) {$\lor$};

\node[gate] (g3) at (1.3,10) {$\land$};
\node[gate] (g4) at (2,10) {$\lor$};

\node[gate] (g5) at (2.3,9) {$\land$};
\node[gate] (g6) at (3,9) {$\lor$};

\node[gate] (g7) at (3.3,8) {$\land$};
\node[gate] (g8) at (4,8) {$\lor$};

\node[gate] (g9) at (4.3,7) {$\land$};
\node[gate] (g10) at (5,7) {$\lor$};

\node[gate] (g11) at (5.3,6) {$\land$};
\node[gate] (g12) at (6,6) {$\lor$};

\node[gate] (g13) at (6.3,5) {$\land$};
\node[gate] (g14) at (7,5) {$\lor$};

\node[gate] (g15) at (7.3,4) {$\land$};
\node[gate] (g16) at (8,4) {$\lor$};

\node[gate] (g17) at (8.3,3) {$\land$};
\node[gate] (g18) at (9,3) {$\lor$};

\node[gate] (g19) at (9.3,2) {$\land$};
\node[gate] (g20) at (10,2) {$\lor$};

\node[gate] (g21) at (0.3,9) {$\lor$};
\node[gate] (g22) at (1.3,8) {$\lor$};
\node[gate] (g23) at (2.3,7) {$\lor$};
\node[gate] (g24) at (3.3,6) {$\lor$};
\node[gate] (g25) at (4.3,5) {$\lor$};
\node[gate] (g26) at (5.3,4) {$\lor$};
\node[gate] (g27) at (6.3,3) {$\lor$};
\node[gate] (g28) at (7.3,2) {$\lor$};
\node[gate] (g29) at (8.3,1) {$\lor$};

\node[gate] (g30) at (10.3,1) {$\land$};
\node[gate, label=right:$w_0$] (g31) at (9.3,0) {$\lor$};

\foreach \f/\t in {x1/g1, x1/g2, x2/g1, x2/g2,
                   g2/g3, g2/g4, x3/g3, x3/g4,
                   g4/g5, g4/g6, x4/g5, x4/g6,
                   g6/g7, g6/g8, x5/g7, x5/g8,
                   g8/g9, g8/g10, x6/g9, x6/g10,
                   g10/g11, g10/g12, x7/g11, x7/g12,
                   g12/g13, g12/g14, x8/g13, x8/g14,
                   g14/g15, g14/g16, x9/g15, x9/g16,
                   g16/g17, g16/g18, x10/g17, x10/g18,
                   g18/g19, g18/g20, x11/g19, x11/g20,
                   g1/g21, g3/g21, g21/g22, g5/g22,
                   g22/g23, g7/g23, g23/g24, g9/g24,
                   g24/g25, g11/g25, g25/g26, g13/g26,
                   g26/g27, g15/g27, g27/g28, g17/g28,
                   g28/g29, g19/g29,
                   x12/g30, g20/g30, g29/g31, g30/g31}
  \draw[->] (\f) -- (\t);
\end{scope}

\end{scope}
\end{mypic}
\caption{$\size(\THR_{12}^2)=31$}
\label{figure:thr31}
\end{figure}

\todo[inline]{Nikita, sdelai, pogaluista, etu shemu bolee gorizontal'noi: pust' vse verhnie or-geiti idut na odnom (gorizontal'nom) urovne}

\begin{figure}[t]
\begin{mypic}
\begin{scope}[scale=.9]
%\draw[help lines] (0,-5) grid (16,6);
\begin{scope}[xshift=20mm, yshift=30mm]
%\draw[help lines] (0,-3) grid (4,4);

\node[input] (x5) at (2, 7) {$x_5$};
\node[input] (x1) at (4, 7) {$x_1$};
\node[input] (x6) at (6, 7) {$x_6$};
\node[input] (x2) at (8, 7) {$x_2$};

\node[gate] (g9) at (1.5,6) {$\lor$};
\node[input] (x9) at (2.5, 6) {$x_9$};
\node[input] (x10) at (3.5, 6) {$x_{10}$};
\node[gate] (g3) at (4.5,6) {$\lor$};
\node[gate] (g11) at (5.5,6) {$\lor$};
\node[input] (x7) at (6.5, 6) {$x_7$};
\node[input] (x3) at (7.5, 6) {$x_3$};
\node[gate] (g0) at (8.5,6) {$\lor$};

\node[gate] (g10) at (1,5) {$\lor$};
\node[gate] (g6) at (2,5) {$\lor$};
\node[gate] (g12) at (3,5) {$\lor$};
\node[input] (x11) at (4, 5) {$x_{11}$};
\node[gate] (g4) at (5,5) {$\lor$};
\node[gate] (g13) at (6,5) {$\lor$};
\node[input] (x8) at (7, 5) {$x_8$};
\node[input] (x4) at (8, 5) {$x_4$};
\node[gate] (g1) at (9,5) {$\lor$};

\node[gate] (g22) at (1.5,4) {$\land$};
\node[gate] (g21) at (2.5,4) {$\lor$};
\node[gate] (g7) at (3.5,4) {$\lor$};
\node[gate] (g14) at (4.5,4) {$\lor$};
\node[input] (x12) at (5.5, 4) {$x_{12}$};
\node[gate] (g5) at (6.5,4) {$\lor$};
\node[gate] (g15) at (7.5,4) {$\lor$};
\node[gate] (g2) at (8.5,4) {$\lor$};

\node[gate] (g24) at (2.5,3) {$\land$};
\node[gate] (g23) at (3.5,3) {$\lor$};
\node[gate] (g8) at (4.5,3) {$\lor$};
\node[gate] (g16) at (5.5,3) {$\lor$};
\node[gate] (g17) at (6.5,3) {$\lor$};
\node[gate] (g18) at (7.5,3) {$\land$};

\node[gate] (g25) at (2.5,2) {$\lor$};
\node[gate] (g26) at (4,2) {$\land$};
\node[gate] (g19) at (5,2) {$\land$};

\node[gate] (g27) at (4,1) {$\lor$};
\node[gate] (g20) at (5,1) {$\lor$};

\node[gate, label=right:$w_0$] (g28) at (4.5,0) {$\lor$};

\foreach \f/\t in {x5/g9, x1/g9, x5/g3, x6/g3, x6/g11, x2/g11, x2/g0, x1/g0,
                   g9/g10, x9/g10, x9/g6, x10/g6, x10/g12, g11/g12, g3/g4, x7/g4, x7/g13, x3/g13, x3/g1, g0/g1,
                   g10/g22, g10/g21, g6/g7, g12/g22, g12/g21, x11/g7, x11/g14, g4/g5, g13/g14, x8/g5, x8/g15, x4/g15, x4/g2, g1/g2,
                   g22/g25, g21/g24, g21/g23, g7/g8, g14/g24, g14/g23, x12/g8, x12/g16, g5/g17, g5/g18, g15/g16, g2/g17, g2/g18,
                   g24/g25, g23/g26, g8/g19, g16/g26, g17/g19, g18/g20,
                   g25/g27, g26/g27, g19/g20,
                   g27/g28, g20/g28}
  \draw[->] (\f) -- (\t);
\end{scope}

\end{scope}
\end{mypic}
\caption{$\size(\THR_{12}^2)=29$}
\label{figure:thr29}
\end{figure}

Our program is~not able to~find out that the circuit 
of~size~$31$ is~suboptimal. It~would be~interesting to~find
a~way extending the program to~make it~possible.

\section{Further Directions}
In~the paper, we~focus mainly on~proving asymptotic upper bounds for function families (that is, that work for every input size). 
A~natural further step is~to~apply the program 
to~specific circuits that are used in~practice.

It~would also be~interesting to~extend the program 
so~that it~is able to~discover the circuit from Figure~\ref{figure:thr29}.

\bibliography{circuits}

\appendix
\section{Blocks for the Modulo~3 Function}
The following code justifies the existence of~circuits needed in the proof of Theorem~\ref{theorem:mod3upper}.
\inputminted{python}{mod3_check.py}

